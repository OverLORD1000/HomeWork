public class operatorprecedence {
    public static void main(String[] args) {
        int a = 5;
        int b = 2;
        int c = 8;
        System.out.println(a + b / c); // первым деление 2/8 = 0.25 на бумаге, но для int = 0 + 5 = 5
        System.out.println((a + b) / c); // в скобках сложение первым получили 7 делим на 8, на бумаге получаем 0.875 для int = 0
        System.out.println((a + b++) / c); // в скобках сложение первым получили 7 делим на 8, на бумаге получаем 0.875 для int = 0
        System.out.println((a + b++) / --c); // b = 3 c предыдущей операции, в скобках сложение первым получили 8, 8/7 = 1,14 для int = 1
        if(c != 8) {
            c = 8;
        }
        System.out.println((a * b >> b++) / --c); // с начала т.к пост-унарная операция b++ => 4
         // c прошлой операции добавилось 1, --с = 7 , затем 5 * b = 5  т.к. увеличилось на 1 от b++ => 25
         // 25 >> 4 т.е. 11001 >> 1 и делим на 7 = 0,14 для int = 0
        int d = 7;
        int f = 20;
        int e = 68;
        int w = 22;
        if(c != 8) {
            c = 8;
        }
        System.out.println((a + d > f ? e : w * b >> b++) / --c); // b++ = 5 c прошлой операции => значит b = 6 , --c = 7 по условию т.к.
        // нельзя менять переменную "c", a + d = 12 это меньше 20 значит выполняется выражение w * b >> b++ = 22 * 6 >> 5 = 4 => 4/7 =
        // = 0.57 для int = 0
        if(c != 8) {
            c = 8;
        }

        //System.out.println((a + d > f ? e >= e : w * b>> b++) / --c); // b++ = 6 c прошлой операции => значит b = 7, --c = 7 по
        // условию т.к. нельзя менять переменную "c", a + d = 12 это меньше 20 значит выполняется выражение w * b >> b++ = 22 * 7 >> 6 =
        // = 2 => 2/7 = 0.28 для int = 0 но выскакивает ошибка, хотя если отдельно посчитать (a + d > f ? e >= e : w * b>> b++)
        // то idea считает тоже 2
        System.out.println(6 - 2 > 3 && 12 * 12 <= 119); // 12 * 12 = 144 <= 119 => false значит неважно что у нас левое выражение true
        // т.к. правое false
        System.out.println(true && false); // будет false , т.к. чтобы было true нужно чтобы обе стороны были true

    }
}
